
<!DOCTYPE html>
<html>
  <head>
    <style>
      .TreeNode, .Container {
        background-position: left top;
        background-size: 1em;
        background-repeat: no-repeat;
      }
      .TreeNode .TreeNode {
        padding-left: 1em;
        background-image: url(child.svg);
      }
      .TreeNode .TreeNode .Container {
        padding-left: 1em;
        margin-left: -1em;
        background-image: url(extend-child.svg);
        background-repeat: repeat-y;
      }
      .TreeNode .TreeNode:last-child {
        background-image: url(last-child.svg);
      }
      .TreeNode .TreeNode:last-child .Container {
        background-image: none;
      }
    </style>
    <script src="fGetIPAddresses.js"></script>
    <script src="fXHRScanIPAddressPorts.js"></script>
    <script>
      onload = function() {
        fGetIPAddresses(
          oIFrame,
          function fGetIPAddressSuccessCallback(asIPAddresses) {
            if (asIPAddresses.length == 0) {
              document.body.appendChild(new cTreeNode("Your local IP address could not be determined.", "error.svg").oRootElement);
            } else {
              var aoNetworkTreeNodes = [];
              asIPAddresses.forEach(function (sIPAddress, uIndex) {
                var oNetworkTreeNode = new cTreeNode("Network for " + sIPAddress + "/8:", "network.svg");
                document.body.appendChild(oNetworkTreeNode.oRootElement);
                aoNetworkTreeNodes[uIndex] = oNetworkTreeNode;
              });
              var uIndex = -1;
              function fScanNetworks() {
                if (++uIndex < asIPAddresses.length) {
                  fScanNetworkForIPAddress(asIPAddresses[uIndex], aoNetworkTreeNodes[uIndex], fScanNetworks);
                };
              };
              fScanNetworks();
              
              function fScanNetworkForIPAddress(sOwnIPAddress, oNetworkTreeNode, fCallback) {
                oNetworkTreeNode.setIcon("scanning.svg");
                var asIPAddressComponents = /((?:[0-9]{1,3}\.){3})([0-9]{1,3})/.exec(sOwnIPAddress),
                    sFirstBytes = asIPAddressComponents[1],
                    sLastByte = asIPAddressComponents[2],
                    aoMachineTreeNodes = [];
                for (var uLastByte = 0; uLastByte < 256; uLastByte++) {
                  var sIPAddress = sFirstBytes + uLastByte,
                      oTreeNode = sIPAddress == sOwnIPAddress ? new cTreeNode(sIPAddress + " (you)", "machine.svg") : new cTreeNode("");
                  aoMachineTreeNodes[uLastByte] = oNetworkTreeNode.appendChild(oTreeNode);
                };
                uLastByte = -1;
                function fScanAddressRange() {
                  if (++uLastByte < 256) {
                    if (sFirstBytes + uLastByte == sOwnIPAddress) {
                      fScanAddressRange();
                    } else {
                      fScanIPAddress(sFirstBytes + uLastByte, aoMachineTreeNodes[uLastByte], fScanAddressRange);
                    };
                  } else {
                    oNetworkTreeNode.setIcon("network.svg");
                    fCallback();
                  };
                }
                for (var uThreads = 64; uThreads--;) {
                  fScanAddressRange();
                };
              };
            };
          },
          function fGetIPAddressErrorCallback(sErrorMessage) {
            document.body.appendChild(new cTreeNode(sErrorMessage, "error.svg").oRootElement);
          }
        );
      };
      
      function fScanIPAddress(sIPAddress, oMachineTreeNode, fCallback) {
        oMachineTreeNode.setName(sIPAddress);
        oMachineTreeNode.setIcon("scanning.svg");
        var dsDescription_by_sPortNumber = {
              "80":     "HTTP server",
              "443":    "HTTPS server",
              "445":    "SMB shares (Microsoft-DS)",
              "3389":   "RDP (Microsoft Terminal Server)",
              "28876":  "SkyLined",
              "31337":  "leet",
            },
            auPortNumbers = Object.keys(dsDescription_by_sPortNumber).map(function (sPortNumber) { return parseInt(sPortNumber); });
        fXHRScanIPAddressPorts(sIPAddress, auPortNumbers, function(auDetectedPortNumbers) {
          console.warn(auDetectedPortNumbers.length + "==" + Object.keys(dsDescription_by_sPortNumber).length);
          if (auDetectedPortNumbers.length == 0) {
            oMachineTreeNode.remove();
          } else if (auDetectedPortNumbers.length == Object.keys(dsDescription_by_sPortNumber).length) {
            oMachineTreeNode.setIcon("nix.svg");
            oMachineTreeNode.appendChild(new cTreeNode("Ports cannot be scanned for *nix machines", "error.svg"));
          } else {
            if (auDetectedPortNumbers.includes(28876) || auDetectedPortNumbers.includes(31337)) {
              oMachineTreeNode.setIcon("unknown.svg");
              oMachineTreeNode.appendChild(new cTreeNode("Port scan may contain false positives", "unknown.svg"));
            } else if (auDetectedPortNumbers.includes(445) || auDetectedPortNumbers.includes(3389)) {
              oMachineTreeNode.setIcon("windows.svg");
            } else {
              oMachineTreeNode.setIcon("unknown.svg");
            };
            auDetectedPortNumbers.forEach(function(uPortNumber) {
              if (uPortNumber != 28876 && uPortNumber != 31337) {
                var sDescription = dsDescription_by_sPortNumber[uPortNumber];
                oMachineTreeNode.appendChild(new cTreeNode("port " + uPortNumber + " " + sDescription));
              };
            });
          };
          fCallback();
        });
      };
      function cTreeNode(sNodeName, sIconURL) {
        this.oRootElement = document.createElement("div");
        this.oRootElement.className = "TreeNode";
        oNodeElement = this.oRootElement.appendChild(document.createElement("div"))
        this.oNodeIconImageNode = oNodeElement.appendChild(document.createElement("img"));
        this.oNodeIconImageNode.style.setProperty("vertical-align", "top");
        this.oNodeIconImageNode.style.setProperty("width", "1em");
        if (sIconURL) {
          this.oNodeIconImageNode.src = sIconURL;
        } else {
          this.oNodeIconImageNode.style.setProperty("display", "none");
        };
        oNodeNameTextElement = oNodeElement.appendChild(document.createElement("span"))
        this.oNodeNameTextNode = oNodeNameTextElement.appendChild(document.createTextNode(sNodeName));
        oNodeNameTextElement.style.setProperty("margin-left", "0.25em");
        this.oContainerElement = this.oRootElement.appendChild(document.createElement("div"));
        this.oContainerElement.className = "Container";
      };
      cTreeNode.prototype.setName = function cTreeNode_setName(sNewName) {
        this.oNodeNameTextNode.nodeValue = sNewName;
      };
      cTreeNode.prototype.setIcon = function cTreeNode_setName(sIconURL) {
        this.oNodeIconImageNode.style.setProperty("display", "inline-block");
        this.oNodeIconImageNode.src = sIconURL;
      };
      cTreeNode.prototype.appendChild = function cTreeNode_appendChild(oChildTreeNode) {
        this.oContainerElement.appendChild(oChildTreeNode.oRootElement);
        return oChildTreeNode;
      };
      cTreeNode.prototype.remove = function cTreeNode_remove() {
        this.oRootElement.parentNode.removeChild(this.oRootElement);
      };
    </script>
  </head>
  <body>
    <iframe id="oIFrame" sandbox="allow-same-origin" style="display: none"></iframe>
  </body>
</html>